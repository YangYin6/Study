#include<iostream>
#include<vector>
#include<queue>
using namespace std;
int BF(char* a[], int n, char* b[], int m)
{
	for (int i = 0; i < n - m; i++)
	{
		int j = 0;
		while (j < m)
		{
			if (a[i + j] != a[j])
				break;
			j++;
			if (j == m)
				return i;
		}
	}
	return -1;
}
class Graph {
private:
	int v;
	vector<vector<int> >adj;
	void recurDFS(int s, int t, vector<bool>& visted, vector<int>& prev,bool* Found)
	{
		if (*Found)
			return;
		if (s == t)
		{
			*Found = true;
			return;
		}
		for (int i = 0; i < adj[s].size(); i++)
		{
			auto tmp = adj[s][i];
			if (!visted[tmp])
			{
				prev[tmp] = s;
				recurDFS(tmp, t, visted, prev, Found);
			}
		}
	}
	void print(vector<int>& prev,int s,int t)
	{
		if (prev[s] != -1 && t != s)
		{
			print(prev, s, prev[t]);
		}
		cout << t << "->";
	}
public:
	void graph(int v)
	{
		this->v = v;
		for (int i = 0; i < v; i++)
		{
			adj[i] = vector<int>{};
		}
	}
	void addEdge(int s, int t)
	{
		adj[s].push_back(t);
		adj[t].push_back(s);
	}
	void UndirectedBFS(int s, int t)
	{
		if (s == t)	
			return;
		vector<bool>visted;
		queue<int>q;
		vector<int>prev;
		visted[s] = true;
		q.push(s);
		while (!q.empty())
		{
			auto tmp = q.front();	q.pop();
			for (int i = 0; i <adj[tmp].size(); i++)
			{
				auto cnt = adj[tmp][i];
				if (!visted[tmp])
				{
					prev[cnt] = tmp;
					if (cnt == t)
						return;
				}
				visted[cnt] = true;
				q.push(cnt);
			}
		}
		print(prev,s,t);
	}
	void UndirevtedDFS(int s, int t)
	{
		bool found = false;
		vector<bool>visted;
		vector<int>prev;
		for (int i = 0; i < adj.size(); i++)
		{
			prev[i] = -1;
		}
		bool* Found = &found;
		recurDFS(s, t,visted, prev,Found);
	}

};
